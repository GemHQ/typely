// Generated by CoffeeScript 1.9.3
(function() {
  var Signature, type,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  type = require("fairmont").type;

  Signature = (function() {
    function Signature() {
      this.fail = bind(this.fail, this);
      this.signatures = {};
      this.failHandler = (function(_this) {
        return function() {
          return false;
        };
      })(this);
    }

    Signature.prototype.on = function() {
      var i, processor, types;
      types = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), processor = arguments[i++];
      this.signatures[types.join(".")] = processor;
      return this;
    };

    Signature.prototype.fail = function(handler) {
      this.failHandler = handler;
      return this;
    };

    Signature.prototype.match = function(args) {
      var arg, processor, signature, types;
      types = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          results.push(type(arg));
        }
        return results;
      })();
      signature = types.join(".");
      processor = this.signatures[signature];
      if (processor != null) {
        return processor;
      } else {
        console.log(signature);
        console.log(this.signatures);
        return this.failHandler;
      }
    };

    return Signature;

  })();

  module.exports = {
    overload: function(declarator) {
      var fail, match, signature;
      signature = new Signature;
      match = function() {
        var handler, i, types;
        types = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), handler = arguments[i++];
        return signature.on.apply(signature, slice.call(types).concat([handler]));
      };
      fail = function(handler) {
        return signature.fail(handler);
      };
      declarator(match, fail);
      return function() {
        var args, ref;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return (ref = signature.match(args)).call.apply(ref, [this].concat(slice.call(args)));
      };
    }
  };

}).call(this);
